/*----------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-----------------------------------------------------------------------*/
-->begin

#if !defined(COCO_SCANNER_H__)
#define COCO_SCANNER_H__

#include <limits.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_BUFFER_LENGTH (64*1024)
#define HEAP_BLOCK_SIZE 64*1024

// string handling
char* coco_string_create(const char* value);
char* coco_string_create(const char *value , int startIndex, int length);
void  coco_string_delete(char* &data);
void  coco_string_set(char* &data, const char* value);
int   coco_string_length(char* data);
bool  coco_string_endswith(char* data, char *value);
int   coco_string_indexof(char* data, char value);
int   coco_string_lastindexof(char* data, char value);
char* coco_string_append(const char* data1, const char* data2);
void  coco_string_merge(char* &data, char* value);
void  coco_string_merge(char* &data, char value);
char* coco_string_substring(char* data, int startIndex, int length);
char* coco_string_toupper(char* data);
char* coco_string_tolower(char* data);
char  coco_string_charat(char* data, int subscript);
bool  coco_string_equal(char* data1, char* data2);
int   coco_string_compareto(char* data1, char* data2);

-->namespace_open

class BitArray  
{
public:
	BitArray(int length = 0, bool defaultValue = false) ;
	BitArray(const BitArray &copy );
	~BitArray();

	int getCount();

	bool Get(int index);
	void Set(int index, bool value);
	void SetAll(bool value);
	bool Equal( const BitArray &right );
	bool operator[]( int index ) const;

	const BitArray &operator=( const BitArray &right );

	void Not();
	void And(BitArray value);
	void Or(BitArray value);
	void Xor(BitArray value);

	BitArray &Clone();

private:
	int Count;
	unsigned char* Data;
	void setMem(int length, bool value);

};

class Token  
{
public:
	int kind;     // token kind
	int pos;      // token position in the source text (starting at 0)
	int col;      // token column (starting at 0)
	int line;     // token line (starting at 1)
	char* val;    // token value
	Token *next;  // ML 2005-03-11 Peek tokens are kept in linked list

	Token();
	~Token();

};

class Buffer {
private:
	char *buf;          // input buffer
	int bufStart;       // position of first byte in buffer relative to input stream
	int bufLen;         // length of buffer
	int fileLen;        // length of input stream
	int pos;            // current position in buffer
	FILE* stream;      // input stream (seekable)
	bool isUserStream;  // was the stream opened by the user?
	
public:
	const int EoF;

	Buffer(FILE* s, bool isUserStream);
	~Buffer();
	
	void Close();
	int Read();
	int Peek();
	char* GetString(int beg, int end);
	int getPos();
	void setPos(int value);
};

class Scanner {
private:
	void *firstHeap;
	void *heap;
	void *heapTop;
	void *heapEnd;

	char EOL;
	int eofSym;
	int noSym;
	int maxT;
	int charSetSize;
	short *start;

	Token *t;         // current token
	char *tval;       // text of current token
	int tvalLength;   // length of text of current token
	int tlen;         // length of current token

	Token *tokens;    // list of tokens already peeked (first token is a dummy)
	Token *pt;        // current peek token

	int ch;           // current input character
-->casing0
	int pos;          // column number of current character
	int line;         // line number of current character
	int lineStart;    // start position of current line
	int oldEols;      // EOLs that appeared in a comment;
	BitArray *ignore; // set of characters to be ignored by the scanner

	void CreateHeapBlock();
	Token* CreateToken();
	void AppendVal(Token *t);

	void Init();
	void NextCh();
	void AddCh();
-->commentsheader
	void CheckLiteral();
	Token* NextToken();

public:
	Buffer *buffer;   // scanner buffer
	
	Scanner(char* fileName);
	Scanner(FILE* s);
	~Scanner();
	Token* Scan();
	Token* Peek();
	void ResetPeek();

}; // end Scanner

-->namespace_close

#endif // !defined(COCO_SCANNER_H__)

-->implementation
/*-------------------------------------------------------------------------
Compiler Generator Coco/R,
Copyright (c) 1990, 2004 Hanspeter Moessenboeck, University of Linz
extended by M. Loeberbauer & A. Woess, Univ. of Linz
ported to C++ by Csaba Balazs, University of Szeged
with improvements by Pat Terry, Rhodes University

This program is free software; you can redistribute it and/or modify it 
under the terms of the GNU General Public License as published by the 
Free Software Foundation; either version 2, or (at your option) any 
later version.

This program is distributed in the hope that it will be useful, but 
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
for more details.

You should have received a copy of the GNU General Public License along 
with this program; if not, write to the Free Software Foundation, Inc., 
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.

As an exception, it is allowed to write an extension of Coco/R that is
used as a plugin in non-free software.

If not otherwise stated, any source code generated by Coco/R (other than 
Coco/R itself) does not fall under the GNU General Public License.
-------------------------------------------------------------------------*/
-->begin

#include "Scanner.h"
#include <memory.h>
#include <string.h>

char* coco_string_create(const char* value) {
	char* data;
	if (value) {
		int length = strlen(value);
		data = new char[length+1];
		strcpy(data, value);
	} else {
		data = new char[1];
		data[0] = 0;
	}
	return data;
}

char* coco_string_create(const char *value , int startIndex, int length) {
	char* data;
	if (value) {
		data = new char[length+1];
		strncpy(data, &(value[startIndex]), length);
		data[length] = 0;
	} else {
		data = new char[1];
		data[0] = 0;
	}
	return data;
}

void coco_string_delete(char* &data) {
	if (data)
		delete data;
	data = NULL;
}

void coco_string_set(char* &data, const char* value) {
	char* newData;
	if (value) {
		int length = strlen(value);
		newData = new char[length+1];
		strcpy(newData, value);
	} else {
		newData = new char[1];
		newData[0] = 0;
	}
	char* oldData = data;
	delete oldData;
	data = newData;
}

int coco_string_length(char* data) {
	if (data)
		return strlen(data);
	else
		return 0;
}

bool coco_string_endswith(char* data, char *value) {
	int dataLen  = strlen(data);
	int valueLen = strlen(value);
	if (valueLen <= dataLen) {
		return !strcmp(data+dataLen-valueLen, value);
	} else
		return false;
}

int coco_string_indexof(char* data, char value) {
	char* chr = strchr(data, value);

	if (chr)
		return (chr-data);
	else
		return -1;
}

int coco_string_lastindexof(char* data, char value) {
	char* chr = strrchr(data, value);

	if (chr)
		return (chr-data);
	else
		return -1;
}

char* coco_string_append(const char* data1, const char* data2) {
	char* data;

	if (!data1 && !data2)
		return NULL;

	int data1Len = 0;
	if (data1)
		data1Len = strlen(data1);
	int data2Len = 0;
	if (data2)
		data2Len = strlen(data2);

	data = new char[data1Len+data2Len+1];

	if (data1)
		strcpy(data, data1);
	if (data2)
		strcpy(data+data1Len, data2);

	data[data1Len+data2Len] = 0;

	return data;
}

void coco_string_merge(char* &data, char* value) {
	if (!value)
		return;

	char* newData;

	int dataLen = 0;
	if (data)
		dataLen = strlen(data);
	int valueLen = 0;
	if (value)
		valueLen = strlen(value);

	newData = new char[dataLen+valueLen+1];

	if (data)
		strcpy(newData, data);
	if (value)
		strcpy(newData+dataLen, value);

	newData[dataLen+valueLen] = 0;

	if (data)
		delete data;

	data = newData;
}

void coco_string_merge(char* &data, char value) {
	char* newData;

	int dataLen = 0;
	if (data)
		dataLen = strlen(data);

	newData = new char[dataLen+2];

	if (data)
		strcpy(newData, data);

	newData[ dataLen ] = value;
	newData[dataLen+1] = 0;

	data = newData;
}


char* coco_string_substring(char* data, int startIndex, int length) {
	char* newData;
	if (data) {
		newData = new char[length+1];
		strncpy(newData, &(data[startIndex]), length);
		newData[length] = 0;
	} else {
		newData = new char[1];
		newData[0] = 0;
	}
	return newData;
}

char* coco_string_toupper(char* data) {
	if (!data)
		return NULL;

	char* newData;

	int dataLen = 0;
	if (data)
		dataLen = strlen(data);

	newData = new char[dataLen+1];

	for (int i=0; i<=dataLen; i++) {
		if (('a' <= data[i]) && (data[i] <= 'z'))
			newData[i] = data[i] + ('A'-'a');
		else
			newData[i] = data[i];
	}
	newData[dataLen] = '\0';

	return newData;
}

char* coco_string_tolower(char* data) {
	if (!data)
		return NULL;

	char* newData;

	int dataLen = 0;
	if (data)
		dataLen = strlen(data);

	newData = new char[dataLen+1];

	for (int i=0; i<=dataLen; i++) {
		if (('A' <= data[i]) && (data[i] <= 'Z'))
			newData[i] = data[i] - ('A'-'a');
		else
			newData[i] = data[i];
	}
	newData[dataLen] = '\0';

	return newData;
}

char coco_string_charat(char* data, int subscript) {
	if (!data)
		return 0;

	int dataLen = 0;
	if (data)
		dataLen = strlen(data);

	if( subscript < 0 || subscript >= dataLen ) {
		return 0;
	}

	return data[subscript];
}

bool coco_string_equal(char* data1, char* data2) {
	return strcmp( data1, data2 ) == 0; 
}

int coco_string_compareto(char* data1, char* data2) {
	return strcmp(data1, data2);
}

-->namespace_open

BitArray::BitArray(int length, bool defaultValue)
{
	Count = length;
	Data = new unsigned char[ (length+7)>>3 ];
	if (defaultValue)
		memset(Data, 0xFF, (length+7)>>3);
	else
		memset(Data, 0x00, (length+7)>>3);
}

BitArray::BitArray(const BitArray &copy) {
	Count  = copy.Count;
	Data = new unsigned char[ (copy.Count+7)>>3 ];
	memcpy(Data, copy.Data, (copy.Count+7)>>3);
}

BitArray::~BitArray()
{
	delete [] Data;
}

int BitArray::getCount() {
	return Count;
}

bool BitArray::Get(int index)
{
	return (Data[(index>>3)] & (1 << (index&7))) != 0;
}

bool BitArray::operator[]( int index ) const
{
	return (Data[(index>>3)] & (1 << (index&7))) != 0;
}

void BitArray::Set(int index, bool value)
{
	if (value){
		Data[(index>>3)] |= (1 << (index&7));
	} else {
		unsigned char mask = 0xFF;
		mask ^= (1 << (index&7));
		Data[(index>>3)] &= mask;
	}
}

void BitArray::SetAll(bool value)
{
	if (value)
		memset(Data, 0xFF, (Count+7)>>3);
	else
		memset(Data, 0x00, (Count+7)>>3);
}


void BitArray::Not()
{
	for (int i=0; i<(Count+7)>>3; i++) {
		Data[i] ^= 0xFF;
	}
}

void BitArray::And(BitArray value)
{
	for (int i=0; (i<(Count+7)>>3) && (i<(value.Count+7)>>3); i++) {
		Data[i] = (Data[i] & value.Data[i]);
	}
}

void BitArray::Or(BitArray value)
{
	for (int i=0; (i<(Count+7)>>3) && (i<(value.Count+7)>>3); i++) {
		Data[i] = (Data[i] | value.Data[i]);
	}
}

void BitArray::Xor(BitArray value)
{
	for (int i=0; (i<(Count+7)>>3) && (i<(value.Count+7)>>3); i++) {
		Data[i] = (Data[i] ^ value.Data[i]);
	}
}

BitArray &BitArray::Clone()
{
	BitArray *newBitArray = new BitArray(Count);
	newBitArray->Count = Count;
	memcpy(newBitArray->Data, Data, (Count+7)>>3);
	return *newBitArray;
}

bool BitArray::Equal( const BitArray &right )
{
	if (Count != right.Count) {
		return false;
	} else {
		for(int i=0; i<Count; i++)
			if ((Data[(i>>3)] & (1<<(i&7))) != (right.Data[(i>>3)] & (1<<(i&7))))
				return false;
	}
	return true;
}

const BitArray &BitArray::operator=( const BitArray &right )
{
	if ( &right != this ) {         // avoid self assignment
		delete [] Data;              // prevents memory leak
		Count  = right.Count;
		Data = new unsigned char[ (Count+7)>>3 ];
		memcpy(Data, right.Data, (Count+7)>>3);
	}
	return *this;   // enables cascaded assignments
}

Token::Token() {
	kind = 0;
	pos  = 0;
	col  = 0;
	line = 0;
	val  = NULL;
	next = NULL;
}

Token::~Token() {
	coco_string_delete(val);
}


Buffer::Buffer(FILE* s, bool isUserStream) :EoF(256) {
	stream = s; this->isUserStream = isUserStream;
	fseek(s, 0, SEEK_END);
	bufLen = ftell(s);
	fileLen = bufLen;
	fseek(s, 0, SEEK_SET);
	bufLen = MAX_BUFFER_LENGTH;
	buf = new char[bufLen];
	bufStart = INT_MAX; // nothing in the buffer so far
	setPos(0);          // setup  buffer to position 0 (start)
	if (bufLen == fileLen) Close();
}

Buffer::~Buffer() {
	Close(); 
	delete [] buf;
}

void Buffer::Close() {
	if (!isUserStream && stream != NULL) {
		fclose(stream);
		stream = NULL;
	}
}

int Buffer::Read() {
	if (pos < bufLen) {
		return buf[pos++];
	} else if (getPos() < fileLen) {
		setPos(getPos()); // shift buffer start to Pos
		return buf[pos++];
	} else {
		return EoF;
	}
}

int Buffer::Peek() {
	if (pos < bufLen) {
		return buf[pos];
	} else if (getPos() < fileLen) {
		setPos(getPos()); // shift buffer start to pos
		return buf[pos];
	} else {
		return EoF;
	}
}

char* Buffer::GetString(int beg, int end) {
	int len = end - beg;
	char *buf = new char[len];
	int oldPos = getPos();
	setPos(beg);
	for (int i = 0; i < len; ++i) buf[i] = (char) Read();
	setPos(oldPos);
	return buf;
}

int Buffer::getPos() {
	return pos + bufStart;
}

void Buffer::setPos(int value) {
	if (value < 0) value = 0;
	else if (value > fileLen) value = fileLen;
	if (value >= bufStart && value < bufStart + bufLen) { // already in buffer
		pos = value - bufStart;
	} else if (stream != NULL) { // must be swapped in
		fseek(stream, value, SEEK_SET);
		bufLen = fread(buf, sizeof(char), MAX_BUFFER_LENGTH, stream);
		bufStart = value; pos = 0;
	} else {
		pos = fileLen - bufStart; // make Pos return fileLen
	}
}


Scanner::Scanner(char* fileName) {
	FILE* stream;
	if ((stream = fopen(fileName, "rb")) == NULL) {
		printf("--- Cannot open file %s\n", fileName);
		exit(1);
	}
	buffer = new Buffer(stream, false);
	Init();
}
	
Scanner::Scanner(FILE* s) {
	buffer = new Buffer(s, true);
	Init();
}

Scanner::~Scanner() {
	void* cur = firstHeap;

	while(cur != NULL) {
		cur = *((void**) ((int) cur + HEAP_BLOCK_SIZE));
		free(firstHeap);
		firstHeap = cur;
	}
	delete [] start;
	delete [] tval;
	delete ignore;
	delete buffer;
}

void Scanner::Init() {
	EOL    = '\n';
	eofSym = 0;
-->declarations

	tvalLength = 128;
	tval = new char[tvalLength]; // text of current token

	// HEAP_BLOCK_SIZE byte heap + pointer to next heap block
	heap = malloc(HEAP_BLOCK_SIZE + sizeof(void*));
	firstHeap = heap;
	heapEnd = (void*) (((int) heap) + HEAP_BLOCK_SIZE);
	*(int*) heapEnd = 0;
	heapTop = heap;
	if (sizeof(Token) > HEAP_BLOCK_SIZE) {
		printf("--- Too small HEAP_BLOCK_SIZE\n");
		exit(1);
	}

	pos = -1; line = 1; lineStart = 0;
	oldEols = 0;
	NextCh();
	ignore = new BitArray(charSetSize+1);
	ignore->Set(' ', true);  // blanks are always white space
-->initialization
	pt = tokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh() {
	if (oldEols > 0) { ch = EOL; oldEols--; } 
	else {
		ch = buffer->Read(); pos++; //(char)
		// replace isolated '\r' by '\n' in order to make
		// eol handling uniform across Windows, Unix and Mac
		if (ch == '\r' && buffer->Peek() != '\n') ch = EOL;
		if (ch == EOL) { line++; lineStart = pos + 1; }
	}
-->casing1
}

void Scanner::AddCh() {
	if (tlen >= tvalLength) {
		tvalLength *= 2;
		char *newBuf = new char[tvalLength];
		memcpy(newBuf, tval, tlen*sizeof(char));
		delete tval;
		tval = newBuf;
	}
-->casing2
	NextCh();
}

-->comments

void Scanner::CheckLiteral() {
-->literals
}

void Scanner::CreateHeapBlock() {
	void* newHeap;
	void* cur = firstHeap;

	while(((int) tokens < (int) cur) || ((int) tokens > ((int) cur + HEAP_BLOCK_SIZE))) {
		cur = *((void**) ((int) cur + HEAP_BLOCK_SIZE));
		free(firstHeap);
		firstHeap = cur;
	}

	// HEAP_BLOCK_SIZE byte heap + pointer to next heap block
	newHeap = malloc(HEAP_BLOCK_SIZE + sizeof(void*));
	*(int*) heapEnd = (int) newHeap;
	heapEnd = (void*) (((int) newHeap) + HEAP_BLOCK_SIZE);
	*(int*) heapEnd = 0;
	heap = newHeap;
	heapTop = heap;
}

Token* Scanner::CreateToken() {
	Token *t;
	if (((int) sizeof(Token) + (int) heapTop) >= (int) heapEnd) {
		CreateHeapBlock();
	}
	t = (Token*) heapTop;
	heapTop = (void*) ((int) heapTop + sizeof(Token));
	t->val = NULL;
	t->next = NULL;
	return t;
}

void Scanner::AppendVal(Token *t) {
	if ((tlen + 1 + (int) heapTop) >= (int) heapEnd) {
		if (tlen + 1 > HEAP_BLOCK_SIZE) {
			printf("--- Too long token value\n");
			exit(1);
		}
		CreateHeapBlock();
	}
	t->val = (char*) heapTop;
	heapTop = (void*) ((int) heapTop + tlen + 1);
	strncpy(t->val, tval, tlen);
	t->val[tlen] = 0;
}

Token* Scanner::NextToken() {
	while ((*ignore)[ch]) NextCh();
-->scan1
	t = CreateToken();
	t->pos = pos; t->col = pos - lineStart + 1; t->line = line; 
	int state = start[ch];
	tlen = 0; AddCh();

	switch (state) {
		case -1: { t->kind = eofSym; break; } // NextCh already done
		case 0: { t->kind = noSym; break; }   // NextCh already done
-->scan2
	}
	AppendVal(t);
	return t;
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan() {
	if (tokens->next == NULL) {
		return tokens = NextToken();
	} else {
		pt = tokens = tokens->next;
		return tokens;
	}
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek() {
	if (pt->next == NULL) {
		do {
			pt = pt->next = NextToken();
		} while (pt->kind > maxT); // skip pragmas
	} else {
		do {
			pt = pt->next; 
		} while (pt->kind > maxT);
	}
	return pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek() {
	pt = tokens;
}

-->namespace_close

$$$